//////////////////////////////////////////////////////////////////////////
///	< Author >	< Anthony Poschen >
///	< Date >	< 11/12/2012 >
/// < File >	< float2 >
/// < Brief >	< a 2D Vector implementation. for float2 >
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
///	< Includes >
#include "float2.h"
#include "CoreMath.h"
#include "../core/bzPython.h"
//////////////////////////////////////////////////////////////////////////
/// < Forward Declares >


//////////////////////////////////////////////////////////////////////////
float2::float2()
	:X(0),Y(0)
{

}

//////////////////////////////////////////////////////////////////////////
float2::float2(const float2& a_kVec)
	:X(a_kVec.X),Y(a_kVec.Y)
{

}

//////////////////////////////////////////////////////////////////////////
float2::float2(float a_fX,float a_fY)
	:X(a_fX),Y(a_fY)
{

}

//////////////////////////////////////////////////////////////////////////
float2::~float2()
{

}

//////////////////////////////////////////////////////////////////////////
float float2::Length() const
{
	return bzSqrt(X * X + Y * Y);
}

//////////////////////////////////////////////////////////////////////////
float float2::SqrLength() const
{
	return (X * X + Y * Y);
}

//////////////////////////////////////////////////////////////////////////
float float2::Unitise()
{
	float fSum = X + Y;
	X < 0 ? fSum -= X*2 : 0;
	Y < 0 ? fSum -= Y*2 : 0;
	X /= fSum;
	Y /= fSum;
	return fSum;
}

//////////////////////////////////////////////////////////////////////////
float float2::UnitiseVector(float2 &a_kVec)
{
	float fSum = a_kVec.X + a_kVec.Y;
	a_kVec.X < 0 ? fSum -= a_kVec.X*2 : 0;
	a_kVec.Y < 0 ? fSum -= a_kVec.Y*2 : 0;
	a_kVec.X /= fSum;
	a_kVec.Y /= fSum;
	return fSum;
}

//////////////////////////////////////////////////////////////////////////
float float2::DotProduct(const float2 &a_kVec)
{
	return ((X * a_kVec.X) + (Y * a_kVec.Y));
}

//////////////////////////////////////////////////////////////////////////
float2 float2::PerpendicularRight()
{
	return float2(Y, -X);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::PerpendiculerLeft()
{
	return float2(-Y, X);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::Lerp(const float2& a_kBegin,const float2 &a_kEnd,const float a_fTime)
{
	float2 kResult;
	kResult.X = a_kBegin.X + (a_fTime*(a_kEnd.X - a_kBegin.X));
	kResult.Y = a_kBegin.Y + (a_fTime*(a_kEnd.Y - a_kBegin.Y));
	return kResult;
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator + (const float2 &a_kTarget)
{
	return float2(X + a_kTarget.X , Y + a_kTarget.Y);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator - (const float2 &a_kTarget)
{
	return float2(X - a_kTarget.X , Y - a_kTarget.Y);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator * (const float2 &a_kTarget)
{
	return float2(X * a_kTarget.X , Y * a_kTarget.Y);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator / (const float2 &a_kTarget)
{
	return float2(X / a_kTarget.X , Y / a_kTarget.Y);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator * (const float &a_fScale)
{
	return float2(X * a_fScale , Y * a_fScale);
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator / (const float &a_fScale)
{
	return float2(X / a_fScale ,  Y / a_fScale);
}

//////////////////////////////////////////////////////////////////////////
void float2::operator = (const float2 &a_kVec)
{
	X = a_kVec.X;
	Y = a_kVec.Y;
}

//////////////////////////////////////////////////////////////////////////
bool float2::operator == (const float2 &a_kVec)
{
	if( X == a_kVec.X && Y == a_kVec.Y )
		return true;
	return false;
}

//////////////////////////////////////////////////////////////////////////
float2 float2::operator - ()
{
	return float2(-X , -Y);
}

//////////////////////////////////////////////////////////////////////////
bool float2::operator != (const float2 &a_kVec)
{
	if( X != a_kVec.X || Y != a_kVec.Y )
		return true;
	return false;
}

//////////////////////////////////////////////////////////////////////////
void float2::operator += (const float2 &a_kVec)
{
	X += a_kVec.X;
	Y += a_kVec.Y;
}

//////////////////////////////////////////////////////////////////////////
void float2::operator -= (const float2 &a_kVec)
{
	X -= a_kVec.X;
	Y -= a_kVec.Y;
}

//////////////////////////////////////////////////////////////////////////
void float2::operator *= (const float2 &a_kVec)
{
	X *= a_kVec.X;
	Y *= a_kVec.Y;
}

//////////////////////////////////////////////////////////////////////////
void float2::operator /= (const float2 &a_kVec)
{
	 X /= a_kVec.X;
	 Y /= a_kVec.Y;
}

//////////////////////////////////////////////////////////////////////////
void float2::operator *= (const float &a_fScale)
{
	X *= a_fScale;
	Y *= a_fScale;
}

//////////////////////////////////////////////////////////////////////////
void float2::operator /= (const float &a_fScale)
{
	X /= a_fScale;
	Y /= a_fScale;
}

//////////////////////////////////////////////////////////////////////////
bool float2::operator < (const float2 &a_kVec)
{
	if(SqrLength() < a_kVec.SqrLength())
		return true;
	return false;
}

//////////////////////////////////////////////////////////////////////////
bool float2::operator > (const float2 &a_kVec)
{
	if(SqrLength() > a_kVec.SqrLength())
		return true;
	return false;
}